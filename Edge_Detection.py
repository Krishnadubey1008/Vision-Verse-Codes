# -*- coding: utf-8 -*-
"""Untitled8.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1orfz36dYEEd21nGffxJXwxyp59hqlBpG

FOR FIRST IMAGE

CANNY EDGE DETECTION
"""

import cv2
import matplotlib.pyplot as plt

def apply_canny_edge_detection(img_path, low_threshold, high_threshold):

    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)

    # Apply Gaussian blur for reducing noise and improving edge detection
    blurred_img = cv2.GaussianBlur(img, (5, 5), 0)

    # Apply Canny edge detection
    edges = cv2.Canny(blurred_img, low_threshold, high_threshold)

    return edges

def main():

    img_path = "/content/2.jpeg"

    # Setting Canny edge detection parameters
    low_threshold = 68
    high_threshold = 140

    # Applying Canny edge detection
    edges = apply_canny_edge_detection(img_path, low_threshold, high_threshold)

    # Display of original and Canny edge-detected img
    plt.figure(figsize=(10, 5))

    plt.subplot(1, 2, 1)
    plt.imshow(cv2.cvtColor(cv2.imread(img_path), cv2.COLOR_BGR2RGB))
    plt.title('Original Image')
    plt.axis('off')

    plt.subplot(1, 2, 2)
    plt.imshow(edges, cmap='gray')
    plt.title('Canny Edge Detection')
    plt.axis('off')

    plt.show()

if __name__ == "__main__":
    main()

"""Hough Transform

"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

def apply_hough_transform(img_path):

    img = cv2.imread(img_path, cv2.IMREAD_GRAYSCALE)

    # Apply Gaussian blur to reduce noise and improve edge detection
    blurred_img = cv2.GaussianBlur(img, (5, 5), 0)

    # Apply Canny edge detection
    edges = cv2.Canny(blurred_img, 50, 150)

    # Apply Hough Transform to detect lines
    lines = cv2.HoughLines(edges, 1, np.pi / 180, threshold=100)

    # Draw the lines on a copy of the original image
    img_with_lines = img.copy()
    if lines is not None:
        for line in lines:
            rho, theta = line[0]
            a = np.cos(theta)
            b = np.sin(theta)
            x0 = a * rho
            y0 = b * rho
            x1 = int(x0 + 1000 * (-b))
            y1 = int(y0 + 1000 * (a))
            x2 = int(x0 - 1000 * (-b))
            y2 = int(y0 - 1000 * (a))
            cv2.line(img_with_lines, (x1, y1), (x2, y2), (0, 0, 255), 2)

    return img_with_lines

def main():
    # Path to the input image
    img_path = "/content/2.jpeg"

    # Apply Hough Transform for edge detection
    result_img = apply_hough_transform(img_path)

    # Display the original and Hough Transform result images side by side
    plt.figure(figsize=(10, 5))

    plt.subplot(1, 2, 1)
    plt.imshow(cv2.cvtColor(cv2.imread(img_path), cv2.COLOR_BGR2RGB))
    plt.title('Original Image')
    plt.axis('off')

    plt.subplot(1, 2, 2)
    plt.imshow(cv2.cvtColor(result_img, cv2.COLOR_BGR2RGB))
    plt.title('Edge Detection using Hough Transform')
    plt.axis('off')

    plt.show()

if __name__ == "__main__":
    main()

"""Laplacian"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

def apply_laplacian_edge_detection(image_path):
    # Read the image
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

    # Apply Laplacian operator
    laplacian = cv2.Laplacian(image, cv2.CV_64F)

    # Convert the result to uint8
    laplacian = np.uint8(np.absolute(laplacian))

    return laplacian

def main():
    # Path to the input image
    image_path = "/content/2.jpeg"

    # Apply Laplacian edge detection
    laplacian_edges = apply_laplacian_edge_detection(image_path)

    # Display the original and Laplacian edge-detected images side by side
    plt.figure(figsize=(10, 5))

    plt.subplot(1, 2, 1)
    plt.imshow(cv2.cvtColor(cv2.imread(image_path), cv2.COLOR_BGR2RGB))
    plt.title('Original Image')
    plt.axis('off')

    plt.subplot(1, 2, 2)
    plt.imshow(laplacian_edges, cmap='gray')
    plt.title('Laplacian Edge Detection')
    plt.axis('off')

    plt.show()

if __name__ == "__main__":
    main()

"""Edge Detection Using Gradients-Sobel,Prewitt,Robert Operators"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

def apply_gradient_edge_detection(image_path):
    # Read the image
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

    # Apply Sobel operator
    sobel_x = cv2.Sobel(image, cv2.CV_64F, 1, 0, ksize=3)
    sobel_y = cv2.Sobel(image, cv2.CV_64F, 0, 1, ksize=3)
    sobel_edges = np.sqrt(sobel_x**2 + sobel_y**2)

    # Convert the result to uint8
    sobel_edges = np.uint8(sobel_edges)

    # Apply Prewitt operator
    prewitt_kernel_x = np.array([[-1, 0, 1], [-1, 0, 1], [-1, 0, 1]])
    prewitt_x = cv2.filter2D(image, cv2.CV_64F, prewitt_kernel_x)

    prewitt_kernel_y = np.array([[-1, -1, -1], [0, 0, 0], [1, 1, 1]])
    prewitt_y = cv2.filter2D(image, cv2.CV_64F, prewitt_kernel_y)

    prewitt_edges = np.sqrt(prewitt_x**2 + prewitt_y**2)
    prewitt_edges = np.uint8(prewitt_edges)

    # Apply Robert operator
    robert_kernel_x = np.array([[1, 0], [0, -1]])
    robert_x = cv2.filter2D(image, cv2.CV_64F, robert_kernel_x)

    robert_kernel_y = np.array([[0, 1], [-1, 0]])
    robert_y = cv2.filter2D(image, cv2.CV_64F, robert_kernel_y)

    robert_edges = np.sqrt(robert_x**2 + robert_y**2)
    robert_edges = np.uint8(robert_edges)

    return sobel_edges, prewitt_edges, robert_edges

def main():
    # Path to the input image
    image_path = "/content/2.jpeg"

    # Apply gradient-based edge detection
    sobel_edges, prewitt_edges, robert_edges = apply_gradient_edge_detection(image_path)

    # Display the original and edge-detected images using different operators
    plt.figure(figsize=(15, 5))

    plt.subplot(1, 4, 1)
    plt.imshow(cv2.cvtColor(cv2.imread(image_path), cv2.COLOR_BGR2RGB))
    plt.title('Original Image')
    plt.axis('off')

    plt.subplot(1, 4, 2)
    plt.imshow(sobel_edges, cmap='gray')
    plt.title('Sobel Edge Detection')
    plt.axis('off')

    plt.subplot(1, 4, 3)
    plt.imshow(prewitt_edges, cmap='gray')
    plt.title('Prewitt Edge Detection')
    plt.axis('off')

    plt.subplot(1, 4, 4)
    plt.imshow(robert_edges, cmap='gray')
    plt.title('Robert Edge Detection')
    plt.axis('off')

    plt.show()

if __name__ == "__main__":
    main()

"""FOR SECOND IMAGE

CANNY EDGE DETECTION
"""

import cv2
import matplotlib.pyplot as plt

def apply_canny_edge_detection(image_path, low_threshold, high_threshold):
    # Read the image
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

    # Apply Gaussian blur to reduce noise and improve edge detection
    blurred_image = cv2.GaussianBlur(image, (5, 5), 0)

    # Apply Canny edge detection
    edges = cv2.Canny(blurred_image, low_threshold, high_threshold)

    return edges

def main():
    # Path to the input image
    image_path = "/content/3.jpeg"

    # Setting Canny edge detection parameters
    low_threshold = 68
    high_threshold = 140

    # Applying Canny edge detection
    edges = apply_canny_edge_detection(image_path, low_threshold, high_threshold)

    # Display of original and Canny edge-detected image
    plt.figure(figsize=(10, 5))

    plt.subplot(1, 2, 1)
    plt.imshow(cv2.cvtColor(cv2.imread(image_path), cv2.COLOR_BGR2RGB))
    plt.title('Original Image')
    plt.axis('off')

    plt.subplot(1, 2, 2)
    plt.imshow(edges, cmap='gray')
    plt.title('Canny Edge Detection')
    plt.axis('off')

    plt.show()

if __name__ == "__main__":
    main()

"""HOUGH TRANFORM"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

def apply_hough_transform(image_path):
    # Read the image
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

    # Apply Gaussian blur to reduce noise and improve edge detection
    blurred_image = cv2.GaussianBlur(image, (5, 5), 0)

    # Apply Canny edge detection
    edges = cv2.Canny(blurred_image, 50, 150)

    # Apply Hough Transform to detect lines
    lines = cv2.HoughLines(edges, 1, np.pi / 180, threshold=100)

    # Draw the lines on a copy of the original image
    image_with_lines = image.copy()
    if lines is not None:
        for line in lines:
            rho, theta = line[0]
            a = np.cos(theta)
            b = np.sin(theta)
            x0 = a * rho
            y0 = b * rho
            x1 = int(x0 + 1000 * (-b))
            y1 = int(y0 + 1000 * (a))
            x2 = int(x0 - 1000 * (-b))
            y2 = int(y0 - 1000 * (a))
            cv2.line(image_with_lines, (x1, y1), (x2, y2), (0, 0, 255), 2)

    return image_with_lines

def main():
    # Path to the input image
    image_path = "/content/3.jpeg"

    # Apply Hough Transform for edge detection
    result_image = apply_hough_transform(image_path)

    # Display the original and Hough Transform result images side by side
    plt.figure(figsize=(10, 5))

    plt.subplot(1, 2, 1)
    plt.imshow(cv2.cvtColor(cv2.imread(image_path), cv2.COLOR_BGR2RGB))
    plt.title('Original Image')
    plt.axis('off')

    plt.subplot(1, 2, 2)
    plt.imshow(cv2.cvtColor(result_image, cv2.COLOR_BGR2RGB))
    plt.title('Edge Detection using Hough Transform')
    plt.axis('off')

    plt.show()

if __name__ == "__main__":
    main()

"""LAPLACIAN"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

def apply_laplacian_edge_detection(image_path):

    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

    # Applying Laplacian
    laplacian = cv2.Laplacian(image, cv2.CV_64F)

    # Converting result to uint8
    laplacian = np.uint8(np.absolute(laplacian))

    return laplacian

def main():

    image_path = "/content/3.jpeg"

    # Applying Laplacian edge detection
    laplacian_edges = apply_laplacian_edge_detection(image_path)

    # Displaying the original and Laplacian edge-detected images
    plt.figure(figsize=(10, 5))

    plt.subplot(1, 2, 1)
    plt.imshow(cv2.cvtColor(cv2.imread(image_path), cv2.COLOR_BGR2RGB))
    plt.title('Original Image')
    plt.axis('off')

    plt.subplot(1, 2, 2)
    plt.imshow(laplacian_edges, cmap='gray')
    plt.title('Laplacian Edge Detection')
    plt.axis('off')

    plt.show()

if __name__ == "__main__":
    main()

"""Edge Detection Using Gradients-Sobel,Prewitt,Robert Operators

"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

def apply_gradient_edge_detection(image_path):
    # Read the image
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

    # Apply Sobel operator
    sobel_x = cv2.Sobel(image, cv2.CV_64F, 1, 0, ksize=3)
    sobel_y = cv2.Sobel(image, cv2.CV_64F, 0, 1, ksize=3)
    sobel_edges = np.sqrt(sobel_x**2 + sobel_y**2)

    # Convert the result to uint8
    sobel_edges = np.uint8(sobel_edges)

    # Apply Prewitt operator
    prewitt_kernel_x = np.array([[-1, 0, 1], [-1, 0, 1], [-1, 0, 1]])
    prewitt_x = cv2.filter2D(image, cv2.CV_64F, prewitt_kernel_x)

    prewitt_kernel_y = np.array([[-1, -1, -1], [0, 0, 0], [1, 1, 1]])
    prewitt_y = cv2.filter2D(image, cv2.CV_64F, prewitt_kernel_y)

    prewitt_edges = np.sqrt(prewitt_x**2 + prewitt_y**2)
    prewitt_edges = np.uint8(prewitt_edges)

    # Apply Robert operator
    robert_kernel_x = np.array([[1, 0], [0, -1]])
    robert_x = cv2.filter2D(image, cv2.CV_64F, robert_kernel_x)

    robert_kernel_y = np.array([[0, 1], [-1, 0]])
    robert_y = cv2.filter2D(image, cv2.CV_64F, robert_kernel_y)

    robert_edges = np.sqrt(robert_x**2 + robert_y**2)
    robert_edges = np.uint8(robert_edges)

    return sobel_edges, prewitt_edges, robert_edges

def main():
    # Path to the input image
    image_path = "/content/3.jpeg"

    # Apply gradient-based edge detection
    sobel_edges, prewitt_edges, robert_edges = apply_gradient_edge_detection(image_path)

    # Display the original and edge-detected images using different operators
    plt.figure(figsize=(15, 5))

    plt.subplot(1, 4, 1)
    plt.imshow(cv2.cvtColor(cv2.imread(image_path), cv2.COLOR_BGR2RGB))
    plt.title('Original Image')
    plt.axis('off')

    plt.subplot(1, 4, 2)
    plt.imshow(sobel_edges, cmap='gray')
    plt.title('Sobel Edge Detection')
    plt.axis('off')

    plt.subplot(1, 4, 3)
    plt.imshow(prewitt_edges, cmap='gray')
    plt.title('Prewitt Edge Detection')
    plt.axis('off')

    plt.subplot(1, 4, 4)
    plt.imshow(robert_edges, cmap='gray')
    plt.title('Robert Edge Detection')
    plt.axis('off')

    plt.show()

if __name__ == "__main__":
    main()

"""FOR THIRD IMAGE

CANNY EDGE DETECTION
"""

import cv2
import matplotlib.pyplot as plt

def apply_canny_edge_detection(image_path, low_threshold, high_threshold):
    # Read the image
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

    # Apply Gaussian blur to reduce noise and improve edge detection
    blurred_image = cv2.GaussianBlur(image, (5, 5), 0)

    # Apply Canny edge detection
    edges = cv2.Canny(blurred_image, low_threshold, high_threshold)

    return edges

def main():
    # Path to the input image
    image_path = "/content/4.jpg"

    # Setting Canny edge detection parameters
    low_threshold = 68
    high_threshold = 140

    # Applying Canny edge detection
    edges = apply_canny_edge_detection(image_path, low_threshold, high_threshold)

    # Display of original and Canny edge-detected image
    plt.figure(figsize=(10, 5))

    plt.subplot(1, 2, 1)
    plt.imshow(cv2.cvtColor(cv2.imread(image_path), cv2.COLOR_BGR2RGB))
    plt.title('Original Image')
    plt.axis('off')

    plt.subplot(1, 2, 2)
    plt.imshow(edges, cmap='gray')
    plt.title('Canny Edge Detection')
    plt.axis('off')

    plt.show()

if __name__ == "__main__":
    main()

"""HOUGH TRANFORM"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

def apply_hough_transform(image_path):
    # Read the image
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

    # Apply Gaussian blur to reduce noise and improve edge detection
    blurred_image = cv2.GaussianBlur(image, (5, 5), 0)

    # Apply Canny edge detection
    edges = cv2.Canny(blurred_image, 50, 150)

    # Apply Hough Transform to detect lines
    lines = cv2.HoughLines(edges, 1, np.pi / 180, threshold=100)

    # Draw the lines on a copy of the original image
    image_with_lines = image.copy()
    if lines is not None:
        for line in lines:
            rho, theta = line[0]
            a = np.cos(theta)
            b = np.sin(theta)
            x0 = a * rho
            y0 = b * rho
            x1 = int(x0 + 1000 * (-b))
            y1 = int(y0 + 1000 * (a))
            x2 = int(x0 - 1000 * (-b))
            y2 = int(y0 - 1000 * (a))
            cv2.line(image_with_lines, (x1, y1), (x2, y2), (0, 0, 255), 2)

    return image_with_lines

def main():
    # Path to the input image
    image_path = "/content/4.jpg"

    # Apply Hough Transform for edge detection
    result_image = apply_hough_transform(image_path)

    # Display the original and Hough Transform result images side by side
    plt.figure(figsize=(10, 5))

    plt.subplot(1, 2, 1)
    plt.imshow(cv2.cvtColor(cv2.imread(image_path), cv2.COLOR_BGR2RGB))
    plt.title('Original Image')
    plt.axis('off')

    plt.subplot(1, 2, 2)
    plt.imshow(cv2.cvtColor(result_image, cv2.COLOR_BGR2RGB))
    plt.title('Edge Detection using Hough Transform')
    plt.axis('off')

    plt.show()

if __name__ == "__main__":
    main()

"""LAPLACIAN"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

def apply_laplacian_edge_detection(image_path):
    # Read the image
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

    # Apply Laplacian operator
    laplacian = cv2.Laplacian(image, cv2.CV_64F)

    # Convert the result to uint8
    laplacian = np.uint8(np.absolute(laplacian))

    return laplacian

def main():
    # Path to the input image
    image_path = "/content/4.jpg"

    # Apply Laplacian edge detection
    laplacian_edges = apply_laplacian_edge_detection(image_path)

    # Display the original and Laplacian edge-detected images side by side
    plt.figure(figsize=(10, 5))

    plt.subplot(1, 2, 1)
    plt.imshow(cv2.cvtColor(cv2.imread(image_path), cv2.COLOR_BGR2RGB))
    plt.title('Original Image')
    plt.axis('off')

    plt.subplot(1, 2, 2)
    plt.imshow(laplacian_edges, cmap='gray')
    plt.title('Laplacian Edge Detection')
    plt.axis('off')

    plt.show()

if __name__ == "__main__":
    main()

"""Edge Detection Using Gradients-Sobel,Prewitt,Robert Operators"""

import cv2
import numpy as np
import matplotlib.pyplot as plt

def apply_gradient_edge_detection(image_path):
    # Read the image
    image = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)

    # Apply Sobel operator
    sobel_x = cv2.Sobel(image, cv2.CV_64F, 1, 0, ksize=3)
    sobel_y = cv2.Sobel(image, cv2.CV_64F, 0, 1, ksize=3)
    sobel_edges = np.sqrt(sobel_x**2 + sobel_y**2)

    # Convert the result to uint8
    sobel_edges = np.uint8(sobel_edges)

    # Apply Prewitt operator
    prewitt_kernel_x = np.array([[-1, 0, 1], [-1, 0, 1], [-1, 0, 1]])
    prewitt_x = cv2.filter2D(image, cv2.CV_64F, prewitt_kernel_x)

    prewitt_kernel_y = np.array([[-1, -1, -1], [0, 0, 0], [1, 1, 1]])
    prewitt_y = cv2.filter2D(image, cv2.CV_64F, prewitt_kernel_y)

    prewitt_edges = np.sqrt(prewitt_x**2 + prewitt_y**2)
    prewitt_edges = np.uint8(prewitt_edges)

    # Apply Robert operator
    robert_kernel_x = np.array([[1, 0], [0, -1]])
    robert_x = cv2.filter2D(image, cv2.CV_64F, robert_kernel_x)

    robert_kernel_y = np.array([[0, 1], [-1, 0]])
    robert_y = cv2.filter2D(image, cv2.CV_64F, robert_kernel_y)

    robert_edges = np.sqrt(robert_x**2 + robert_y**2)
    robert_edges = np.uint8(robert_edges)

    return sobel_edges, prewitt_edges, robert_edges

def main():
    # Path to the input image
    image_path = "/content/4.jpg"

    # Apply gradient-based edge detection
    sobel_edges, prewitt_edges, robert_edges = apply_gradient_edge_detection(image_path)

    # Display the original and edge-detected images using different operators
    plt.figure(figsize=(15, 5))

    plt.subplot(1, 4, 1)
    plt.imshow(cv2.cvtColor(cv2.imread(image_path), cv2.COLOR_BGR2RGB))
    plt.title('Original Image')
    plt.axis('off')

    plt.subplot(1, 4, 2)
    plt.imshow(sobel_edges, cmap='gray')
    plt.title('Sobel Edge Detection')
    plt.axis('off')

    plt.subplot(1, 4, 3)
    plt.imshow(prewitt_edges, cmap='gray')
    plt.title('Prewitt Edge Detection')
    plt.axis('off')

    plt.subplot(1, 4, 4)
    plt.imshow(robert_edges, cmap='gray')
    plt.title('Robert Edge Detection')
    plt.axis('off')

    plt.show()

if __name__ == "__main__":
    main()
